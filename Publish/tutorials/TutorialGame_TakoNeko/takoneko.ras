program TakoNeko;
var  
//	levels: IncBin("levels/takonekolevel.flf", "$1100"); // 2400 in hex
/*	levels: IncBin("levels/test2.flf", "$1500"); // 2400 in hex
	levelChar: IncBin("charsets/charset_intro.bin","$4000");// $800 bytes
	levelChar2: IncBin("charsets/charset_intro.bin","$8000");// $800 bytes
*/

	levels: IncBin("levels/takonekolevel.flf", "$2000"); // 2400 in hex
	levelChar: IncBin("charsets/charset_takoneko.bin","$4000");// $800 bytes
	sprites0: IncBin("sprites/takoneko.bin", "$4C00");

//	sprite0data : incbin("sprites/fastfood.bin", "$5800"); // will be $1000 bytes // locally 2000


	levelChar2: IncBin("charsets/charset_takoneko.bin","$8000");// $800 bytes
	sprites1: IncBin("sprites/takoneko.bin", "$8C00");
	regularChar: IncBin("charsets/charset_text.bin","$C000");// $800 bytes


	@define pspritepos $40

	background:byte=0;

	tmp2, blockx, blocky, scroll, direction,m:byte=0;

	spritex, tmp:integer;
	speedup, speeddown:byte=0;
	spritey:byte;
	perform:byte;
	m_posx, m_posy, m_tmp : byte;


	m_levelInit : byte = 0;

	m_currentPos : byte=19;
	m_currentAb : byte=0;

	g_currentBank: byte=0;

	vscroll: byte=6;
	zeropage3: pointer;

	moveSpriteRight : array[8] of byte = ($30,$31,$32,$31,$30, $31,$32,$31); 
	moveSpriteLeft : array[8] of byte = ($35,$36,$37,$36,$35, $36,$37,$36); 
	moveSpriteLeftIdle : byte = $34; 
	moveSpriteRightIdle : byte = $33; 

	takoSpriteRight : byte = $39;
	takoSpriteLeft : byte = $39;
	bulletSprite : byte = $38;

	
	usedSprites : array[8] of byte = (1,1,0,0,0,0,0,0);

	entity_x : array[8] of byte;
	entity_y : array[8] of byte;
	entity_sx : array[8] of byte;
	entity_sy : array[8] of byte;

	
	


//	test:pointer;
//	test2:pointer;
	i,j,k,time, val:byte=0;
	sprite1_counter: byte=1;

	mask: array[255] of byte=(
	1,1,1,1,0,0,0,0,0,0,  0,0,1,1,1,1,1,1,1,1,   1,1,1,1,1,1,1,1,1,1,  1,0,0,0,0,1,1,1,1,1,
	1,1,1,1,0,0,0,0,0,0,  0,0,1,1,1,1,1,1,1,1,   1,1,1,1,1,1,1,1,1,1,  1,0,0,0,0,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,  0,0,1,1,1,1,1,1,1,1,   0,0,1,1,1,1,1,1,1,1,  1,0,0,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,  0,0,1,1,1,1,1,1,1,1,   0,0,1,1,1,1,1,1,1,1,  1,0,0,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0,   0,0,0,0,0,0,0,0,0,0,  0,0,0,0,0,0,0,0,0,0);


	catText:pointer;

	@define newline 254
	@define cclear 253
	@define cpause 252	


@include "story.ras"



	@define creditsCMax 4 // Time of credz movement

	@define CreditsColors 3
	@define creditsStartX 2
	@define creditsStartY 20
	creditsX: byte= @creditsStartX;
	creditsY: byte= @creditsStartY;


@define usekernal "0"

/*
   Renders a .flf level at map pos x,y
*/

@define playerSprite "0"
@define charmapLevel "$20"
@define charmapText "$12"

@define screen1hi "$48"
@define screenmem1 "^$4800"

@define screen2hi "$88"
@define screenmem2 "^$8800"

@define colorpointer zeropage3

@define spritebank "2"

@include "levelrenderer.ras"

// Updates the sprite & the sprite animation
procedure UpdatePlayerSpriteMovement();
begin
	
	val := joystickup+joystickdown+joystickleft+joystickright;
	if val<>0 then
		val:=1;

	
	sprite1_counter:=sprite1_counter-val;

	if sprite1_counter>200 then
		sprite1_counter := 31;

	// Animation hits at 0 and 10
	
	i:=sprite1_counter/4;

	if (joystickleft =0 and joystickright=0) then begin
		if direction=0 then k:=moveSpriteLeftIdle
		else k:=moveSpriteRightIdle;
	end;

	if (joystickleft=1) then begin 
		k:=moveSpriteLeft[i]; 
		direction:=0; 
	end;
	if (joystickright=1) then begin 
		k:=moveSpriteRight[i]; 
		direction:=1; 
	end;


//	setspriteloc(@playerSprite, moveSprite[i], 1);
	poke(^$47F8 + ^$0400,@playerSprite,k); 
	poke(^$87F8 + ^$0400,@playerSprite,k); 
	
	
end;




procedure UpdatePlayer();
begin
	Joystick();
	BackgroundCollide();
	if (joystickup=1 and blocky=1) then begin
		speedup:=64;
		blocky:=0;
		speeddown:=0;
	end;

	speeddown:=speeddown+2;

	if speedup<>0 then dec(speedup);;
	if speedup<>0 then dec(speedup);;

	if (blocky=0) then begin
		tmp2:=speeddown/16;
		spritey:=spritey+tmp2;
		tmp2:=speedup/16;
		spritey:=spritey-tmp2;
		
		//SCREEN_BG_COL:=BLACK;
	end
	else
		speeddown:=0;

	if (blockx=1) then begin
		joystickright:=0;
		joystickleft:=0;
		//SCREEN_BG_COL:=RED;
	end;

	spritex:=spritex + joystickright-joystickleft;

	scroll:=0;
	if (spritex<160) then begin
		
	end
	else
	begin
		spritex:=160;
		if joystickright=1 then scroll:=1;
		joystickleft:=0;
	end;

//	if joystickdown=1 then spritey:=spritey+1;
//	if joystickup=1 then spritey:=spritey-1;
	spritepos(spritex, spritey, 0);
	UpdatePlayerSpriteMovement();

end;

procedure UpdateEntitySprites(ues_move:byte);
begin
	for i:=2 to 8 do begin
		if usedSprites[i]<>0 then begin
			tmp:=entity_x[i]*2;						
			spritepos(tmp,entity_y[i],i);
			entity_x[i]:=entity_x[i]-ues_move;
			if entity_x[i]<4 then begin // turn off sprite
				usedSprites[i]:=0;
				togglebit(SPRITE_BITMASK,i,0);
			end;
		end;
		
	end;
end;





procedure FindEntities();
var 
	lp: pointer;
begin
	m:=20-m_currentPos;
	lp:=levelpointer;
	for i:=0 to 6 do begin
		val:=lp[0];
		if val=0 then return();
		if (val<10) then begin  // is a sprite!
			asm(";crash");
			if (m=lp[2] and m_currentAb=0) then begin
			k:=2;
			for m:=k to 8 do 
				if (usedSprites[m]=0) then k:=m;

			usedSprites[k]:=k;

			if k=3 then SCREEN_BG_COL:=RED;

			poke(^$47F8 + ^$0400,k,lp[1]); 
			poke(^$87F8 + ^$0400,k,lp[1]); 
			togglebit(SPRITE_BITMASK,k,1);
			SPRITE_BITMASK:=$FF;
			//entity_x[k]:=levelpointer[2]*4+10;
			entity_x[k]:=39*4+10;
			entity_y[k]:=lp[3]*8+45;
			end;

		end;
		inczp(lp,m_rl_chunksize);
//		SCREEN_BG_COL:=m_rl_chunksize;
//		entity_x[k]:=
		

	end;

end;


/*procedure UpdateText();
begin
	moveto(1,20,$C8);
	printstring("SO QT I IS KITTEN",0,40);

end;
*/
procedure UpdateCredits();
var
	creditsCounter,l:byte=0;
begin
	k:=$C8; 
	moveto(creditsX, creditsY, k);
	val:=catText[0];

	if val=@cclear then creditsCounter:=0;
	if (creditsCounter<>0) then begin
		l:=creditsCounter&7;
		screenmemory[1]:=138 + l;
		dec(creditsCounter);
		return();
	end;
	screenmemory[1]:=$20;


	creditsCounter := @creditsCMax;


	val:=catText[0];
	inczp(catText,1);


	if val=@cpause then begin
		creditsCounter := @creditsCMax*8;
		return();
	end;

	if val=0 then begin
		catText:=storyText;
		return();
	end;
	if val=@cclear then begin
		creditsX:=@creditsStartX;
		creditsY:=@creditsStartY;

		// Clear screen
		fill(^$C800 + ^20*^40, $20, 120);

		return();
	end;
	if val=@newline then begin
		creditsX:=@creditsStartX;
		inc(creditsY);
		return();
	end;
	inc(creditsX);

	moveto(creditsX, creditsY, k);
	if (val>64 and val<128) then val:=val-64;
	screenmemory[0]:=val;
	screenmemory[1]:=$20;
	dec(creditsCounter);
	
end;





interrupt RasterGame();
begin
	startirq(@usekernal);
	SCREEN_FG_COL:=background;
	inc(time);
	poke(VIC_DATA_LOC, 0, @charmapLevel);
//	UpdatePlayerSprite();
	if (vscroll=6 and perform=1) then begin
		RenderColor();
		FindEntities();
		perform:=0;
		
		inc(m_currentAb);
		if (m_currentAb=2) then begin
			dec(m_currentPos);
			m_currentAb:=0;
			if (m_currentPos>127) then begin
				m_currentPos:=19;
				inc(m_posx);
			end;
		end;
	end;


	scrollx(vscroll);

//	dec(vscroll);
	if (scroll=1) then begin	
		dec(vscroll);
		perform:=1;
		i:=vscroll&1;
		UpdateEntitySprites(i);			

	end;
	if (vscroll>128) then begin
		vscroll:=7;
		//perform:=1;
	end;


	
	if (vscroll=2 and perform=1) then begin
		CopyHScreen(0);
		perform :=0;
	end;

	if (vscroll=4 and perform=1) then begin
		CopyHScreen(1);
		perform:=0;
	end;

	

	hideborderx(0);

	

	if (vscroll=7 and perform=1) then begin
		val:=@screen1hi;
		if (g_currentBank=1) then val:=@screen2hi;
		moveto(0,1, val);
		screenmemory[39]:=$20;
		RenderLevel(levels, m_posx, m_posy, val,19,20,m_currentPos, m_currentAb);
		perform:=1;
	end;

	UpdateCredits();

	waitforraster(193);
	wait(13);
	SCREEN_FG_COL:=GREEN;
	scrollx(0);
	setbank(VIC_BANK3);
	
	UpdatePlayer();


	waitforraster(235);
	if g_currentBank=0 then 
		SetBank(VIC_BANK2)
	else 
		SetBank(VIC_BANK1);


	if (vscroll=7 and perform=1) then begin
		SwitchBank();
		CopyHScreenCol(0);
		CopyHScreenCol(1);
		perform:=0;
	end;


	closeirq();
end;



procedure InitSprites();
begin

	// Black and yellow are our colors
	poke(SPRITE_MULTICOLOR_REG1, 0, BLACK);
	poke(SPRITE_MULTICOLOR_REG2, 0, DARK_GREY);

    poke(SPRITE_BITMASK,0, %00000001);

	poke(SPRITE_COLOR,0, PURPLE);

	poke(SPRITE_MULTICOLOR, 0, $FF); // ALL multicolor

	spritepos(spritex,spritey,0);

end;




procedure InitNewGame();
begin
	m_posx:=0;
	m_posy:=0;

	// Initial map rendering
//	ResetLevels();
//	levelpointer := levels;
	setbank(VIC_BANK2);
	setmulticolormode();
	poke(VIC_DATA_LOC, 0, @charmapLevel);
	levelpointer := levels;
	clearscreen($20,@screenmem2);
	clearscreen($20,@screenmem1);
	clearscreen($20,^$C800);
	fill(^$D800 + ^20*^40, 240,0);

	levelpointer:=levels;
	ReadLevelheader();
	levelpointer:=levels;
	m_screen:=@screen2hi;
	m_li:=0;
	m_lj:=0;
	RenderFullLevel();
	m_posx:=1;
	// Initial sprite position
	spritex := 160;
	spritey := 100;	

	speedup:=0;


	poke(MULTICOLOR_CHAR_COL, 0, BLACK);
	poke(MULTICOLOR_CHAR_COL, 2, LIGHT_BLUE); 
	poke(MULTICOLOR_CHAR_COL, 1, DARK_GREY);
	SCREEN_BG_COL:=CYAN;
	background := SCREEN_BG_COL;
	SCREEN_BG_COL:=BLACK;

	poke(MULTICOLOR_CHAR_COL, 0, background);
	poke(MULTICOLOR_CHAR_COL, 2, ORANGE); 
	poke(MULTICOLOR_CHAR_COL, 1, DARK_GREY);

	catText:=storyText;


	InitSprites();
end;



begin
	setmemoryconfig(1,@usekernal,0);
	DisableCIAInterrupts();
	InitNewGame();
	RasterIRQ(RasterGame(), 0, @usekernal);
	enableirq();
	enablerasterirq();
	Loop();
end.
